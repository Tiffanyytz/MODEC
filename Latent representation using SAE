from keras.wrappers.scikit_learn import KerasRegressor
import numpy as np
float_formatter = lambda x: "%.3f" % x
np.set_printoptions(formatter={'float_kind':float_formatter})
from sklearn.datasets.samples_generator import make_circles
from sklearn.cluster import SpectralClustering, KMeans
from sklearn.metrics import pairwise_distances
from matplotlib import pyplot as plt
import networkx as nx
import seaborn as sns
sns.set()
from sklearn.decomposition import PCA
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_samples, silhouette_score
from scipy import stats
import math
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras import Model
from tensorflow.keras import Sequential
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.layers import Dense, Dropout
from sklearn.model_selection import train_test_split
from tensorflow.keras.losses import MeanSquaredLogarithmicError
from tensorflow import keras
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPRegressor

X_tr_std, X_valid_std = train_test_split(df_merge3, train_size=0.67)
X_test = X_valid_std
X_train = X_tr_std
y_test = X_valid_std
y_train = X_tr_std

autoencoder = MLPRegressor(alpha=1e-15, 
                           hidden_layer_sizes=(60, 30, 25, 30, 60),
                          random_state=1, max_iter=20000)
autoencoder.fit(X_train, X_train)

W = autoencoder.coefs_
biases = autoencoder.intercepts_

for w in W:
    print(w.shape)

encoder_weights = W[0:4]
encoder_biases = biases[0:4]

def encode(encoder_weights, encoder_biases, data):
    res_ae  = data
    for index, (w, b) in enumerate(zip(encoder_weights, encoder_biases)):
        if index+1 == len(encoder_weights):
            res_ae = res_ae@w+b
        else:
            res_ae = np.maximum(0, res_ae@w+b)
    return res_ae      
res_ae = encode(encoder_weights, encoder_biases, X_test)

reduced_25 = encode(encoder_weights, encoder_biases, df_merge50)
